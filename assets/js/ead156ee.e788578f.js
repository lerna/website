"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[763],{921:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=t(4848),s=t(8453);const a={id:"distribute-tasks",title:"Distribute Task Execution",type:"recipe"},o="Distribute Task Execution (DTE)",r={id:"features/distribute-tasks",title:"Distribute Task Execution",description:"Lerna speeds up your average CI time with caching and the --since flag. But neither of these features help with the worst case scenario. When something at the core of your repo has been modified and every task needs to be run in CI, the only way to improve the performance is by adding more agent jobs and efficiently parallelizing the tasks.",source:"@site/docs/features/distribute-tasks.md",sourceDirName:"features",slug:"/features/distribute-tasks",permalink:"/docs/features/distribute-tasks",draft:!1,unlisted:!1,editUrl:"https://github.com/lerna/lerna/tree/main/website/docs/features/distribute-tasks.md",tags:[],version:"current",frontMatter:{id:"distribute-tasks",title:"Distribute Task Execution",type:"recipe"},sidebar:"main",previous:{title:"Explore the Project Graph",permalink:"/docs/features/project-graph"},next:{title:"Version and Publish",permalink:"/docs/features/version-and-publish"}},l={},c=[{value:"Set up",id:"set-up",level:2},{value:"CI Execution Flow",id:"ci-execution-flow",level:2},{value:"Running Things in Parallel",id:"running-things-in-parallel",level:2},{value:"CI/CD Examples",id:"cicd-examples",level:2},{value:"Relevant Repositories and Examples",id:"relevant-repositories-and-examples",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"distribute-task-execution-dte",children:"Distribute Task Execution (DTE)"})}),"\n",(0,i.jsxs)(n.p,{children:["Lerna speeds up your average CI time with ",(0,i.jsx)(n.a,{href:"/docs/features/cache-tasks",children:"caching"})," and the ",(0,i.jsx)(n.code,{children:"--since"})," flag. But neither of these features help with the worst case scenario. When something at the core of your repo has been modified and every task needs to be run in CI, the only way to improve the performance is by adding more agent jobs and efficiently parallelizing the tasks."]}),"\n",(0,i.jsx)(n.p,{children:"The most obvious way to parallelize tasks is to split tasks up by type: running all tests on one job, all builds on another and all lint tasks on a third. This strategy is called binning. This can be made difficult if some test tasks have build tasks as prerequisites, but assuming you figure out some way to handle that, a typical set up can look like the diagram below. Here the test tasks are delayed until all necessary build artifacts are ready, but the build and lint tasks can start right away."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"CI using binning",src:t(2039).A+"",width:"730",height:"440"})}),"\n",(0,i.jsx)(n.p,{children:"The problem with the binning approach is you'll end up with some idle time on one or more jobs. Nx's distributed task execution reduces that idle time to the minimum possible by assigning each individual task to agent jobs based on the task's average run time. Nx also guarantees that tasks are executed in the correct order and uses distributed caching to make sure that build artifacts from previous tasks are present on every agent job that needs them."}),"\n",(0,i.jsx)(n.p,{children:"When you set up Nx's distributed task execution, your task graph will look more like this:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"CI using DTE",src:t(2507).A+"",width:"730",height:"440"})}),"\n",(0,i.jsx)(n.p,{children:"And not only will CI finish faster, but the debugging experience is the same as if you ran all of your CI on a single job. That's because Nx uses distributed caching to recreate all of the logs and build artifacts on the main job."}),"\n",(0,i.jsxs)(n.p,{children:["Find more information in this ",(0,i.jsx)(n.a,{href:"https://nx.dev/concepts/dte",children:"detailed guide to improve your worst case CI times"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"set-up",children:"Set up"}),"\n",(0,i.jsx)(n.p,{children:"To distribute your task execution, you need to (1) connect to Nx Cloud and (2) enable DTE in your CI workflow. Each of these steps can be enabled with a single command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",metastring:'title="1. Connect to Nx Cloud"',children:"nx connect-to-nx-cloud\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",metastring:'title="2. Enable DTE in CI"',children:"nx generate @nrwl/workspace:ci-workflow --ci=github\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"--ci"})," flag can be ",(0,i.jsx)(n.code,{children:"github"}),", ",(0,i.jsx)(n.code,{children:"circleci"})," or ",(0,i.jsx)(n.code,{children:"azure"}),". For more details on setting up DTE, read ",(0,i.jsx)(n.a,{href:"https://nx.dev/nx-cloud/set-up/set-up-dte",children:"this guide"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"ci-execution-flow",children:"CI Execution Flow"}),"\n",(0,i.jsx)(n.p,{children:"Distributed task execution can work on any CI provider. You are responsible for launching jobs in your CI system. Nx Cloud then coordinates the way those jobs work together. There are two different kinds of jobs that you'll need to create in your CI system."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"One main job that controls what is going to be executed"}),"\n",(0,i.jsx)(n.li,{children:"Multiple agent jobs that actually execute the tasks"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The main job execution flow looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Coordinate the agents to run the tasks\n- npx nx-cloud start-ci-run\n# Run any commands you want here\n- lerna run lint --since=main & lerna run test --since=main & lerna run build --since=main\n# Stop any run away agents\n- npx nx-cloud stop-all-agents\n"})}),"\n",(0,i.jsx)(n.p,{children:"The agent job execution flow is very simple:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Wait for tasks to execute\n- npx nx-cloud start-agent\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The main job looks more or less the same way as if you haven't used any distribution. The only thing you need to do is\nto invoke ",(0,i.jsx)(n.code,{children:"npx nx-cloud start-ci-run"})," at the beginning and optionally invoke ",(0,i.jsx)(n.code,{children:"npx nx-cloud stop-all-agents"})," at the end."]}),"\n",(0,i.jsxs)(n.p,{children:["The agent jobs run long-running ",(0,i.jsx)(n.code,{children:"start-agent"})," processes that execute all the tasks associated with a given CI run. The\nonly thing you need to do to set them up is to invoke ",(0,i.jsx)(n.code,{children:"npx nx-cloud start-agent"}),". This process will keep running until\nNx Cloud tells it to terminate."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Note it's important that the main job and the agent jobs have the same environment and the same source code. They start\naround the same time. And, once the main job completes, all the agents\nwill be stopped."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It's also important to note that an Nx Cloud agent isn't a machine but rather a long-running process that runs on a\nmachine. I.e., Nx Cloud doesn't manage your agents--you need to do it in your CI config (check out CI examples below)."}),"\n",(0,i.jsx)(n.p,{children:"Nx Cloud is an orchestrator. The main job tells Nx Cloud what you want to run, and Nx Cloud will distribute those tasks\nacross the agents. Nx Cloud will automatically move files from one agent to another, from the agents to the main job."}),"\n",(0,i.jsxs)(n.p,{children:["The end result is that when say ",(0,i.jsx)(n.code,{children:"lerna run build --since=main"})," completes on the main job, all the file artifacts created\non agents are copied over to the main job, as if the main job had built everything locally."]}),"\n",(0,i.jsx)(n.h2,{id:"running-things-in-parallel",children:"Running Things in Parallel"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"--concurrency"})," is propagated to the agents. E.g., ",(0,i.jsx)(n.code,{children:"npx lerna run build --since=main --concurrency=3 --dte"})," tells Nx Cloud to run\nup to 3 build targets in parallel on each agent. So if you have say 10 agents, you will run up to 30 builds in parallel\nacross all of them."]}),"\n",(0,i.jsx)(n.p,{children:"You also want to run as many commands in parallel as you can. For instance,"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- lerna run lint --since=main\n- lerna run test --since=main\n- lerna run build --since=main\n"})}),"\n",(0,i.jsx)(n.p,{children:"is worse than"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- lerna run lint --since=main & lerna run test --since=main & lerna run build --since=main\n"})}),"\n",(0,i.jsx)(n.p,{children:"The latter is going to schedule all the three commands at the same time, so if an agent cannot find anything to build, it will start running tests and lints. The result is better agent utilization and shorter CI time."}),"\n",(0,i.jsx)(n.h2,{id:"cicd-examples",children:"CI/CD Examples"}),"\n",(0,i.jsx)(n.p,{children:"The examples below show how to set up CI using Nx and Nx Cloud using distributed task execution and distributed caching."}),"\n",(0,i.jsx)(n.p,{children:"Every organization manages their CI/CD pipelines differently, so the examples don't cover org-specific aspects of\nCI/CD (e.g., deployment). They mainly focus on configuring Nx correctly."}),"\n",(0,i.jsx)(n.p,{children:"Read the guides for more information on how to configure them in CI."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up",children:"Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-azure",children:"Azure Pipelines"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-circle-ci",children:"Circle CI"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-github-actions",children:"GitHub Actions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-jenkins",children:"Jenkins"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-gitlab",children:"GitLab"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nx.dev/ci/recipes/set-up/monorepo-ci-bitbucket-pipelines",children:"Bitbucket"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note that only cacheable operations can be distributed because they have to be replayed on the main job."}),"\n",(0,i.jsx)(n.h2,{id:"relevant-repositories-and-examples",children:"Relevant Repositories and Examples"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/vsavkin/interstellar",children:"Nx: On how to make your CI 16 times faster with a small config change"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/vsavkin/lerna-dte",children:'"Lerna & Distributed Task Execution" Example'})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},2507:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/3agents-b4eed3c22ef0fe31ac45d1f0ce854b2b.svg"},2039:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/binning-2266f5ba9543a1974a7864232a37a389.svg"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);