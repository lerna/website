"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[923],{8026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=t(4848),i=t(8453);const o={id:"how-caching-works",title:"How Caching Works",type:"explainer"},r="How Caching Works",a={id:"concepts/how-caching-works",title:"How Caching Works",description:"Before running any task, Lerna computes its computation hash. As long as the computation hash is the same, the output of",source:"@site/docs/concepts/how-caching-works.md",sourceDirName:"concepts",slug:"/concepts/how-caching-works",permalink:"/docs/concepts/how-caching-works",draft:!1,unlisted:!1,editUrl:"https://github.com/lerna/lerna/tree/main/website/docs/concepts/how-caching-works.md",tags:[],version:"current",frontMatter:{id:"how-caching-works",title:"How Caching Works",type:"explainer"},sidebar:"main",previous:{title:"Task Pipeline Configuration",permalink:"/docs/concepts/task-pipeline-configuration"},next:{title:"Distributed Task Execution Guide",permalink:"/docs/concepts/dte-guide"}},c={},l=[{value:"Source Code Hash Inputs",id:"source-code-hash-inputs",level:2},{value:"Runtime Hash Inputs",id:"runtime-hash-inputs",level:2},{value:"Args Hash Inputs",id:"args-hash-inputs",level:2},{value:"What is Cached",id:"what-is-cached",level:2},{value:"Skipping Cache",id:"skipping-cache",level:2},{value:"Additional Configuration",id:"additional-configuration",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"how-caching-works",children:"How Caching Works"})}),"\n",(0,s.jsx)(n.p,{children:"Before running any task, Lerna computes its computation hash. As long as the computation hash is the same, the output of\nrunning the task is the same."}),"\n",(0,s.jsxs)(n.p,{children:["By default, the computation hash for - say - ",(0,s.jsx)(n.code,{children:"lerna run test --scope=remixapp"})," includes:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All the source files of ",(0,s.jsx)(n.code,{children:"remixapp"})," and its dependencies"]}),"\n",(0,s.jsx)(n.li,{children:"Relevant global configuration"}),"\n",(0,s.jsx)(n.li,{children:"Versions of external dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Runtime values provisioned by the user such as the version of Node"}),"\n",(0,s.jsx)(n.li,{children:"CLI Command flags"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"computation-hashing",src:t(5466).A+"",width:"2088",height:"1580"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"This behavior is customizable. For instance, lint checks may only depend on the source code of the project and global\nconfigs. Builds can depend on the dts files of the compiled libs instead of their source."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After Lerna computes the hash for a task, it then checks if it ran this exact computation before. First, it checks\nlocally, and then if it is missing, and if a remote cache is configured, it checks remotely."}),"\n",(0,s.jsx)(n.p,{children:"If Lerna finds the computation, Lerna retrieves it and replays it. Lerna places the right files in the right folders and\nprints the terminal output. From the user\u2019s point of view, the command ran the same, just a lot faster."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"cache",src:t(7985).A+"",width:"826",height:"522"})}),"\n",(0,s.jsx)(n.p,{children:"If Lerna doesn\u2019t find a corresponding computation hash, Lerna runs the task, and after it completes, it takes the\noutputs and the terminal logs and stores them locally (and if configured remotely as well). All of this happens\ntransparently, so you don\u2019t have to worry about it."}),"\n",(0,s.jsx)(n.p,{children:"Although conceptually this is fairly straightforward, Lerna optimizes this to make this experience good for you. For\ninstance, Lerna:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Captures stdout and stderr to make sure the replayed output looks the same, including on Windows."}),"\n",(0,s.jsx)(n.li,{children:"Minimizes the IO by remembering what files are replayed where."}),"\n",(0,s.jsx)(n.li,{children:"Only shows relevant output when processing a large task graph."}),"\n",(0,s.jsx)(n.li,{children:"Provides affordances for troubleshooting cache misses. And many other optimizations."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As your workspace grows, the task graph looks more like this:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"cache",src:t(9966).A+"",width:"488",height:"467"})}),"\n",(0,s.jsx)(n.p,{children:"All of these optimizations are crucial for making Lerna usable for any non-trivial workspace. Only the minimum amount of\nwork happens. The rest is either left as is or restored from the cache."}),"\n",(0,s.jsx)(n.h2,{id:"source-code-hash-inputs",children:"Source Code Hash Inputs"}),"\n",(0,s.jsx)(n.p,{children:"The result of building/testing an application or a library depends on the source code of that project and all the source\ncodes of all the libraries it depends on (directly or indirectly)."}),"\n",(0,s.jsxs)(n.p,{children:["By default, Lerna is conservative. When running,\nsay, ",(0,s.jsx)(n.code,{children:"lerna run test --scope=remixapp"})," Lerna will consider all the files in the ",(0,s.jsx)(n.code,{children:"remixapp"})," directory and all the files\nin the ",(0,s.jsx)(n.code,{children:"header"})," and ",(0,s.jsx)(n.code,{children:"footer"})," directories (",(0,s.jsx)(n.code,{children:"remixapp"})," dependencies). This would result in unnecessary cache misses. For\ninstance, we know that changing a ",(0,s.jsx)(n.code,{children:"footer"}),"'s spec file will not change the result of the test command above."]}),"\n",(0,s.jsx)(n.p,{children:"We can define a more precise configuration as follows:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'NOTE: "{projectRoot}" and "{workspaceRoot}" are special syntax supported by the task-runner, which will be appropriately interpolated internally when the command runs. You should therefore not replace "{projectRoot}" or "{workspaceRoot}" with fixed paths as this makes your configuration less flexible.'}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="nx.json"',children:'{\n  "namedInputs": {\n    "default": ["{projectRoot}/**/*"],\n    "prod": ["!{projectRoot}/**/*.spec.tsx"]\n  },\n  "targetDefaults": {\n    "build": {\n      "inputs": ["prod", "^prod"]\n    },\n    "test": {\n      "inputs": ["default", "^prod", "{workspaceRoot}/jest.config.ts"]\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["With this configuration, the build script will only consider the non-test files of ",(0,s.jsx)(n.code,{children:"remixapp"}),", ",(0,s.jsx)(n.code,{children:"header"})," and ",(0,s.jsx)(n.code,{children:"footer"}),".\nThe test script will consider all the source files for the project under test and only non-test files of its\ndependencies. The test script will also consider the jest config file at the root of the workspace."]}),"\n",(0,s.jsx)(n.h2,{id:"runtime-hash-inputs",children:"Runtime Hash Inputs"}),"\n",(0,s.jsx)(n.p,{children:"Your targets can also depend on runtime values."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="nx.json"',children:'{\n  "targetDefaults": {\n    "build": {\n      "inputs": [{ "env": "MY_ENV_NAME" }, { "runtime": "node -v" }]\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"args-hash-inputs",children:"Args Hash Inputs"}),"\n",(0,s.jsxs)(n.p,{children:["Finally, in addition to Source Code Hash Inputs and Runtime Hash Inputs, Lerna needs to consider the arguments: For\nexample, ",(0,s.jsx)(n.code,{children:"lerna run build --scope=remixapp"})," and ",(0,s.jsx)(n.code,{children:"lerna run build --scope=remixapp -- --flag=true"})," produce different\nresults."]}),"\n",(0,s.jsx)(n.p,{children:"Note, only the flags passed to the npm scripts itself affect results of the computation. For instance, the following\ncommands are identical from the caching perspective."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx lerna run build --scope=remixapp\nnpx lerna run build --ignore=header,footer\n"})}),"\n",(0,s.jsx)(n.p,{children:"In other words, Lerna does not cache what the developer types into the terminal."}),"\n",(0,s.jsx)(n.p,{children:"If you build/test/lint\u2026 multiple projects, each individual build has its own hash value and will either be retrieved\nfrom\ncache or run. This means that from the caching point of view, the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx lerna run build --scope=header,footer\n"})}),"\n",(0,s.jsx)(n.p,{children:"is identical to the following two commands:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx lerna run build --scope=header\nnpx lerna run build --scope=footer\n"})}),"\n",(0,s.jsx)(n.h2,{id:"what-is-cached",children:"What is Cached"}),"\n",(0,s.jsx)(n.p,{children:"Lerna works on the process level. Regardless of the tools used to build/test/lint/etc.. your project, the results are\ncached."}),"\n",(0,s.jsx)(n.p,{children:"Lerna sets up hooks to collect stdout/stderr before running the command. All the output is cached and then replayed\nduring a cache hit."}),"\n",(0,s.jsxs)(n.p,{children:["Lerna also caches the files generated by a command. The list of files/folders is listed in the ",(0,s.jsx)(n.code,{children:"outputs"})," property of the\nproject's ",(0,s.jsx)(n.code,{children:"package.json"}),":"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'NOTE: "{projectRoot}" and "{workspaceRoot}" are special syntax supported by the task-runner, which will be appropriately interpolated internally when the command runs. You should therefore not replace "{projectRoot}" or "{workspaceRoot}" with fixed paths as this makes your configuration less flexible.'}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="E.g. packages/my-project/package.json"',children:'{\n  "nx": {\n    "targets": {\n      "build": {\n        "outputs": ["{projectRoot}/build", "{projectRoot}/public/build"]\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If the ",(0,s.jsx)(n.code,{children:"outputs"})," property for a given target isn't defined in the project'\ns ",(0,s.jsx)(n.code,{children:"package.json"})," file, Lerna will look at the ",(0,s.jsx)(n.code,{children:"targetDefaults"})," section of ",(0,s.jsx)(n.code,{children:"nx.json"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="nx.json"',children:'{\n  ...\n  "targetDefaults": {\n    "build": {\n      "dependsOn": [\n        "^build"\n      ],\n      "outputs": [\n        "{projectRoot}/dist",\n        "{projectRoot}/build",\n        "{projectRoot}/public/build"\n      ]\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If neither is defined, Lerna defaults to caching ",(0,s.jsx)(n.code,{children:"dist"})," and ",(0,s.jsx)(n.code,{children:"build"})," at the root of the repository."]}),"\n",(0,s.jsx)(n.h2,{id:"skipping-cache",children:"Skipping Cache"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes you want to skip the cache. If, for example, you are measuring the performance of a command, you can use\nthe ",(0,s.jsx)(n.code,{children:"--skip-nx-cache"})," flag to skip checking the computation cache."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npx lerna run build --skip-nx-cache\nnpx lerna run test --skip-nx-cache\n"})}),"\n",(0,s.jsx)(n.h2,{id:"additional-configuration",children:"Additional Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["For additional ways to configure tasks and caching, see the relevant ",(0,s.jsx)(n.a,{href:"https://nx.dev/recipes/running-tasks",children:"Nx documentation"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},7985:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/cache-c67f30b99d684071f4f042509a39448e.png"},5466:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/lerna-hashing-d90a81e4acb3c97217f66a22f7b8c745.png"},9966:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/task-graph-big-c67fec16567b185ddeed8e7433aad868.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);